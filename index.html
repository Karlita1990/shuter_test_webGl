<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Shooter: –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω–∏–π —Å–≤—ñ—Ç</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            touch-action: none;
            background: #000;
        }
        
        #gameCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
            touch-action: none;
        }
        
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            color: white;
            text-shadow: 2px 2px 2px rgba(0,0,0,0.5);
            font-size: 18px;
            font-weight: bold;
            z-index: 10;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
            pointer-events: none;
        }
        
        #hud div {
            background: rgba(0,0,0,0.5);
            padding: 8px 15px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        #energyBar {
            color: #4CAF50;
        }
        
        #score {
            color: #FFD700;
        }
        
        #level {
            color: #2196F3;
        }
        
        #joystickArea {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            border-radius: 60px;
            background: rgba(255,255,255,0.2);
            backdrop-filter: blur(5px);
            border: 2px solid rgba(255,255,255,0.3);
            z-index: 20;
            touch-action: none;
        }
        
        #joystick {
            width: 60px;
            height: 60px;
            border-radius: 30px;
            background: rgba(255,255,255,0.8);
            position: absolute;
            top: 30px;
            left: 30px;
            touch-action: none;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }
        
        #shootButton {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 100px;
            height: 100px;
            border-radius: 50px;
            background: rgba(255,50,50,0.8);
            backdrop-filter: blur(5px);
            border: 3px solid rgba(255,255,255,0.5);
            color: white;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            touch-action: none;
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
            transition: transform 0.1s;
            user-select: none;
        }
        
        #shootButton:active {
            transform: scale(0.95);
            background: rgba(255,0,0,0.9);
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .modal.active {
            visibility: visible;
            opacity: 1;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 20px;
            color: white;
            max-width: 300px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.2);
        }
        
        .modal-content h2 {
            margin-top: 0;
            font-size: 24px;
        }
        
        .modal-content input {
            width: 80%;
            padding: 12px;
            margin: 15px 0;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            text-align: center;
            background: rgba(255,255,255,0.9);
        }
        
        .modal-content button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s;
            touch-action: manipulation;
        }
        
        .modal-content button:active {
            transform: scale(0.95);
        }
        
        #message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: #4CAF50;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 20px;
            z-index: 50;
            border: 2px solid #4CAF50;
            display: none;
        }
        
        #pauseButton {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 25px;
            background: rgba(255,255,255,0.2);
            backdrop-filter: blur(5px);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 30;
            touch-action: manipulation;
            cursor: pointer;
        }
        
        @media (max-width: 600px) {
            #joystickArea {
                width: 100px;
                height: 100px;
                bottom: 20px;
                left: 20px;
            }
            
            #joystick {
                width: 50px;
                height: 50px;
                top: 25px;
                left: 25px;
            }
            
            #shootButton {
                width: 80px;
                height: 80px;
                bottom: 20px;
                right: 20px;
                font-size: 14px;
            }
            
            #hud {
                font-size: 14px;
                padding: 10px;
            }
            
            #hud div {
                padding: 5px 10px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="hud">
        <div>üîã <span id="energyBar">100</span></div>
        <div>‚≠ê <span id="score">0</span></div>
        <div>üèÜ <span id="level">1</span> - <span id="location">–ú—ñ—Å—Ç–æ</span></div>
    </div>
    
    <div id="joystickArea">
        <div id="joystick"></div>
    </div>
    
    <div id="shootButton">–í–û–ì–û–ù–¨</div>
    
    <div id="pauseButton">‚è∏Ô∏è</div>
    
    <div id="message"></div>
    
    <div class="modal" id="mathModal">
        <div class="modal-content">
            <h2 id="modalTitle">–í–∏—è–≤–ª–µ–Ω–æ –ª–æ–∫–∞—Ü—ñ—é!</h2>
            <p id="modalQuestion">2 + 2 = ?</p>
            <input type="number" id="answerInput" placeholder="–í–∞—à–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å">
            <br>
            <button id="submitAnswer">–í—ñ–¥–ø–æ–≤—ñ—Å—Ç–∏</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/dist/simplex-noise.js"></script>
    
    <script>
        // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è Three.js –∑ WebGL 2.0
        const canvas = document.getElementById('gameCanvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // –û–±–º–µ–∂–µ–Ω–Ω—è –¥–ª—è –º–æ–±—ñ–ª—å–Ω–∏—Ö
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 30, 60);
        
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        
        // –û—Å–≤—ñ—Ç–ª–µ–Ω–Ω—è
        const ambientLight = new THREE.AmbientLight(0x404060);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        // –î–æ–¥–∞—Ç–∫–æ–≤–µ –æ—Å–≤—ñ—Ç–ª–µ–Ω–Ω—è –¥–ª—è –º–æ–±—ñ–ª—å–Ω–∏—Ö
        const fillLight = new THREE.DirectionalLight(0xffccaa, 0.5);
        fillLight.position.set(-1, 0.5, -1);
        scene.add(fillLight);
        
        // –°—Ç–∞–Ω –≥—Ä–∏
        const gameState = {
            energy: 100,
            maxEnergy: 100,
            score: 0,
            level: 1,
            location: '–ú—ñ—Å—Ç–æ',
            isPaused: false,
            isModalOpen: false,
            enemiesKilled: 0,
            bullets: []
        };
        
        // –ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω—ñ –∑–∞–≤–¥–∞–Ω–Ω—è –¥–ª—è –º–æ–¥–∞–ª—å–Ω–∏—Ö –≤—ñ–∫–æ–Ω
        const mathProblems = [
            { question: '2 + 2 = ?', answer: 4 },
            { question: '5 * 3 = ?', answer: 15 },
            { question: '10 - 7 = ?', answer: 3 },
            { question: '8 / 2 = ?', answer: 4 },
            { question: '3 + 5 * 2 = ?', answer: 13 }
        ];
        
        // –õ–æ–∫–∞—Ü—ñ—ó
        const locations = [
            { name: '–ú—ñ—Å—Ç–æ', color: 0x808080, enemyColor: 0xff0000, groundColor: 0x555555 },
            { name: '–î–∂—É–Ω–≥–ª—ñ', color: 0x2ecc71, enemyColor: 0xe67e22, groundColor: 0x27ae60 },
            { name: '–ì–æ—Ä–∏', color: 0x95a5a6, enemyColor: 0xc0392b, groundColor: 0x7f8c8d }
        ];
        
        let currentLocationIndex = 0;
        
        // –°–∏—Å—Ç–µ–º–∞ —á–∞—Å—Ç–∏–Ω–æ–∫ –¥–ª—è –ø–æ—Å—Ç—Ä—ñ–ª—ñ–≤
        const bulletGeometry = new THREE.SphereGeometry(0.1, 4, 4);
        const bulletMaterial = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0x442200 });
        
        // –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —à—É–º—É
        const simplex = new SimplexNoise();
        
        // –ö–µ—Ä—É–≤–∞–Ω–Ω—è
        const joystick = document.getElementById('joystick');
        const joystickArea = document.getElementById('joystickArea');
        const shootButton = document.getElementById('shootButton');
        
        let joystickActive = false;
        let joystickDirection = { x: 0, y: 0 };
        let moveSpeed = 0.15;
        
        // –û–±—Ä–æ–±–∫–∞ –¥–∂–æ–π—Å—Ç–∏–∫–∞
        joystickArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            joystickActive = true;
            updateJoystick(e.touches[0]);
        });
        
        joystickArea.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (joystickActive) {
                updateJoystick(e.touches[0]);
            }
        });
        
        joystickArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            joystickActive = false;
            joystick.style.transform = 'translate(0px, 0px)';
            joystickDirection = { x: 0, y: 0 };
        });
        
        function updateJoystick(touch) {
            const rect = joystickArea.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = rect.width / 2;
            
            if (distance > maxDistance) {
                dx = (dx / distance) * maxDistance;
                dy = (dy / distance) * maxDistance;
            }
            
            joystick.style.transform = `translate(${dx}px, ${dy}px)`;
            
            joystickDirection.x = dx / maxDistance;
            joystickDirection.y = dy / maxDistance;
        }
        
        // –°—Ç—Ä—ñ–ª—å–±–∞
        shootButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.isPaused && !gameState.isModalOpen) {
                shoot();
            }
        });
        
        function shoot() {
            if (gameState.energy < 5) return;
            
            gameState.energy -= 5;
            updateHUD();
            
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial.clone());
            bullet.position.copy(camera.position);
            
            // –ù–∞–ø—Ä—è–º–æ–∫ –ø–æ—Å—Ç—Ä—ñ–ª—É (–≤–ø–µ—Ä–µ–¥ –≤—ñ–¥ –∫–∞–º–µ—Ä–∏)
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            
            bullet.userData = {
                velocity: direction.multiplyScalar(0.5),
                life: 100
            };
            
            scene.add(bullet);
            gameState.bullets.push(bullet);
        }
        
        // –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω–∞ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—è –ª–∞–Ω–¥—à–∞—Ñ—Ç—É
        function generateTerrain(width, depth, scale, location) {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            const normals = [];
            const colors = [];
            
            const segments = 32; // –ó–º–µ–Ω—à–µ–Ω–æ –¥–ª—è –º–æ–±—ñ–ª—å–Ω–∏—Ö
            const stepX = width / segments;
            const stepZ = depth / segments;
            
            // –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –≤–µ—Ä—à–∏–Ω
            for (let i = 0; i <= segments; i++) {
                for (let j = 0; j <= segments; j++) {
                    const x = -width/2 + i * stepX;
                    const z = -depth/2 + j * stepZ;
                    
                    // –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω–∞ –≤–∏—Å–æ—Ç–∞ –Ω–∞ –æ—Å–Ω–æ–≤—ñ —à—É–º—É
                    let y = 0;
                    if (location.name === '–ì–æ—Ä–∏') {
                        y = simplex.noise2D(x * 0.1, z * 0.1) * 3;
                        y += simplex.noise2D(x * 0.3, z * 0.3) * 1.5;
                    } else if (location.name === '–î–∂—É–Ω–≥–ª—ñ') {
                        y = simplex.noise2D(x * 0.2, z * 0.2) * 2;
                        y += Math.abs(simplex.noise2D(x * 0.5, z * 0.5)) * 1;
                    } else {
                        y = simplex.noise2D(x * 0.15, z * 0.15) * 1.5;
                    }
                    
                    vertices.push(x, y, z);
                    
                    // –ö–æ–ª—ñ—Ä –Ω–∞ –æ—Å–Ω–æ–≤—ñ –≤–∏—Å–æ—Ç–∏ —Ç–∞ –ª–æ–∫–∞—Ü—ñ—ó
                    let r, g, b;
                    if (location.name === '–î–∂—É–Ω–≥–ª—ñ') {
                        r = 0.2 + y * 0.1;
                        g = 0.5 + y * 0.15;
                        b = 0.1;
                    } else if (location.name === '–ì–æ—Ä–∏') {
                        r = 0.5 + y * 0.1;
                        g = 0.5 + y * 0.1;
                        b = 0.5 + y * 0.1;
                    } else {
                        r = 0.3 + y * 0.1;
                        g = 0.3 + y * 0.1;
                        b = 0.3 + y * 0.1;
                    }
                    
                    colors.push(r, g, b);
                }
            }
            
            // –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —ñ–Ω–¥–µ–∫—Å—ñ–≤
            for (let i = 0; i < segments; i++) {
                for (let j = 0; j < segments; j++) {
                    const a = i * (segments + 1) + j;
                    const b = i * (segments + 1) + j + 1;
                    const c = (i + 1) * (segments + 1) + j;
                    const d = (i + 1) * (segments + 1) + j + 1;
                    
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            // –û–±—á–∏—Å–ª–µ–Ω–Ω—è –Ω–æ—Ä–º–∞–ª–µ–π
            for (let i = 0; i < indices.length; i += 3) {
                const i1 = indices[i];
                const i2 = indices[i + 1];
                const i3 = indices[i + 2];
                
                const v1 = new THREE.Vector3(vertices[i1*3], vertices[i1*3+1], vertices[i1*3+2]);
                const v2 = new THREE.Vector3(vertices[i2*3], vertices[i2*3+1], vertices[i2*3+2]);
                const v3 = new THREE.Vector3(vertices[i3*3], vertices[i3*3+1], vertices[i3*3+2]);
                
                const normal = new THREE.Vector3();
                const edge1 = new THREE.Vector3().subVectors(v2, v1);
                const edge2 = new THREE.Vector3().subVectors(v3, v1);
                normal.crossVectors(edge1, edge2).normalize();
                
                for (let j = 0; j < 3; j++) {
                    const idx = indices[i + j];
                    normals[idx*3] = (normals[idx*3] || 0) + normal.x;
                    normals[idx*3+1] = (normals[idx*3+1] || 0) + normal.y;
                    normals[idx*3+2] = (normals[idx*3+2] || 0) + normal.z;
                }
            }
            
            // –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è –Ω–æ—Ä–º–∞–ª–µ–π
            for (let i = 0; i < vertices.length/3; i++) {
                const len = Math.sqrt(
                    normals[i*3]*normals[i*3] +
                    normals[i*3+1]*normals[i*3+1] +
                    normals[i*3+2]*normals[i*3+2]
                );
                if (len > 0) {
                    normals[i*3] /= len;
                    normals[i*3+1] /= len;
                    normals[i*3+2] /= len;
                }
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            
            const material = new THREE.MeshStandardMaterial({ 
                vertexColors: true,
                flatShading: false,
                roughness: 0.7,
                metalness: 0.1
            });
            
            return new THREE.Mesh(geometry, material);
        }
        
        // –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –æ–±'—î–∫—Ç—ñ–≤ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –∫–∞—Ä—Ç–∏ —â—ñ–ª—å–Ω–æ—Å—Ç—ñ
        function generateObjects(location) {
            const objects = [];
            const count = location.name === '–î–∂—É–Ω–≥–ª—ñ' ? 30 : location.name === '–ú—ñ—Å—Ç–æ' ? 20 : 15;
            
            for (let i = 0; i < count; i++) {
                // –í–∏–ø–∞–¥–∫–æ–≤–∞ –ø–æ–∑–∏—Ü—ñ—è –≤ –º–µ–∂–∞—Ö —á–∞–Ω–∫—É
                const x = (Math.random() - 0.5) * 40;
                const z = (Math.random() - 0.5) * 40;
                
                // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —â—ñ–ª—å–Ω–æ—Å—Ç—ñ –Ω–∞ –æ—Å–Ω–æ–≤—ñ —à—É–º—É
                const density = Math.abs(simplex.noise2D(x * 0.2, z * 0.2));
                
                if (density > 0.5) {
                    let geometry, material, yOffset = 0;
                    
                    // –í–∏–±—ñ—Ä –æ–±'—î–∫—Ç–∞ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ª–æ–∫–∞—Ü—ñ—ó
                    if (location.name === '–ú—ñ—Å—Ç–æ') {
                        geometry = new THREE.BoxGeometry(1, 2, 1);
                        material = new THREE.MeshStandardMaterial({ color: 0xcc8899 });
                        yOffset = 1;
                    } else if (location.name === '–î–∂—É–Ω–≥–ª—ñ') {
                        geometry = new THREE.ConeGeometry(0.5, 2, 6);
                        material = new THREE.MeshStandardMaterial({ color: 0x2ecc71 });
                        yOffset = 1;
                    } else {
                        geometry = new THREE.CylinderGeometry(0.7, 0.7, 1.5, 6);
                        material = new THREE.MeshStandardMaterial({ color: 0x95a5a6 });
                        yOffset = 0.75;
                    }
                    
                    const obj = new THREE.Mesh(geometry, material);
                    
                    // –û—Ç—Ä–∏–º–∞–Ω–Ω—è –≤–∏—Å–æ—Ç–∏ –ª–∞–Ω–¥—à–∞—Ñ—Ç—É
                    const groundY = simplex.noise2D(x * 0.15, z * 0.15) * 
                        (location.name === '–ì–æ—Ä–∏' ? 3 : location.name === '–î–∂—É–Ω–≥–ª—ñ' ? 2 : 1.5);
                    
                    obj.position.set(x, groundY + yOffset, z);
                    
                    // –í–∏–ø–∞–¥–∫–æ–≤–µ –æ–±–µ—Ä—Ç–∞–Ω–Ω—è
                    obj.rotation.y = Math.random() * Math.PI * 2;
                    
                    scene.add(obj);
                    objects.push(obj);
                }
            }
            
            return objects;
        }
        
        // –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –≤–æ—Ä–æ–≥—ñ–≤
        function generateEnemies(location, count = 5) {
            const enemies = [];
            
            for (let i = 0; i < count; i++) {
                const geometry = new THREE.SphereGeometry(0.5, 8, 8);
                const material = new THREE.MeshStandardMaterial({ 
                    color: location.enemyColor,
                    emissive: 0x330000
                });
                
                const enemy = new THREE.Mesh(geometry, material);
                
                // –ü–æ–∑–∏—Ü—ñ—è –Ω–∞–≤–∫–æ–ª–æ –≥—Ä–∞–≤—Ü—è
                const angle = (i / count) * Math.PI * 2;
                const distance = 15 + Math.random() * 10;
                
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                
                const groundY = simplex.noise2D(x * 0.15, z * 0.15) * 
                    (location.name === '–ì–æ—Ä–∏' ? 3 : location.name === '–î–∂—É–Ω–≥–ª—ñ' ? 2 : 1.5);
                
                enemy.position.set(x, groundY + 0.5, z);
                
                enemy.userData = {
                    health: 30,
                    type: 'enemy',
                    speed: 0.02,
                    patrolAngle: angle
                };
                
                scene.add(enemy);
                enemies.push(enemy);
            }
            
            return enemies;
        }
        
        // –°–∏—Å—Ç–µ–º–∞ —á–∞–Ω–∫—ñ–≤ (Chunk management)
        class ChunkManager {
            constructor(chunkSize = 40, viewDistance = 60) {
                this.chunkSize = chunkSize;
                this.viewDistance = viewDistance;
                this.chunks = new Map();
                this.activeChunks = new Set();
                this.objects = [];
                this.enemies = [];
            }
            
            getChunkKey(x, z) {
                const chunkX = Math.floor(x / this.chunkSize);
                const chunkZ = Math.floor(z / this.chunkSize);
                return `${chunkX},${chunkZ}`;
            }
            
            update(cameraPosition) {
                const currentChunk = this.getChunkKey(cameraPosition.x, cameraPosition.z);
                const chunksToLoad = new Set();
                
                // –í–∏–∑–Ω–∞—á–µ–Ω–Ω—è —á–∞–Ω–∫—ñ–≤ –≤ —Ä–∞–¥—ñ—É—Å—ñ –≤–∏–¥–∏–º–æ—Å—Ç—ñ
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dz = -2; dz <= 2; dz++) {
                        const [chunkX, chunkZ] = currentChunk.split(',').map(Number);
                        const key = `${chunkX + dx},${chunkZ + dz}`;
                        
                        // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤—ñ–¥—Å—Ç–∞–Ω—ñ –¥–æ —á–∞–Ω–∫—É
                        const chunkCenterX = (chunkX + dx) * this.chunkSize + this.chunkSize/2;
                        const chunkCenterZ = (chunkZ + dz) * this.chunkSize + this.chunkSize/2;
                        
                        const distance = Math.sqrt(
                            Math.pow(chunkCenterX - cameraPosition.x, 2) +
                            Math.pow(chunkCenterZ - cameraPosition.z, 2)
                        );
                        
                        if (distance <= this.viewDistance) {
                            chunksToLoad.add(key);
                        }
                    }
                }
                
                // –í–∏–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –Ω–µ–∞–∫—Ç–∏–≤–Ω–∏—Ö —á–∞–Ω–∫—ñ–≤
                for (const key of this.activeChunks) {
                    if (!chunksToLoad.has(key)) {
                        this.unloadChunk(key);
                    }
                }
                
                // –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –Ω–æ–≤–∏—Ö —á–∞–Ω–∫—ñ–≤
                for (const key of chunksToLoad) {
                    if (!this.activeChunks.has(key)) {
                        this.loadChunk(key);
                    }
                }
                
                this.activeChunks = chunksToLoad;
            }
            
            loadChunk(key) {
                const [chunkX, chunkZ] = key.split(',').map(Number);
                const location = locations[currentLocationIndex];
                
                // –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –ª–∞–Ω–¥—à–∞—Ñ—Ç—É –¥–ª—è —á–∞–Ω–∫—É
                const terrain = generateTerrain(this.chunkSize, this.chunkSize, 1, location);
                terrain.position.set(
                    chunkX * this.chunkSize + this.chunkSize/2,
                    0,
                    chunkZ * this.chunkSize + this.chunkSize/2
                );
                
                scene.add(terrain);
                
                // –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –æ–±'—î–∫—Ç—ñ–≤ –¥–ª—è —á–∞–Ω–∫—É
                const objects = generateObjects(location);
                const enemies = generateEnemies(location, 3);
                
                this.chunks.set(key, {
                    terrain,
                    objects,
                    enemies
                });
            }
            
            unloadChunk(key) {
                const chunk = this.chunks.get(key);
                if (chunk) {
                    scene.remove(chunk.terrain);
                    
                    chunk.objects.forEach(obj => scene.remove(obj));
                    chunk.enemies.forEach(enemy => scene.remove(enemy));
                    
                    this.chunks.delete(key);
                }
            }
            
            clear() {
                for (const key of this.chunks.keys()) {
                    this.unloadChunk(key);
                }
            }
        }
        
        // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞ —á–∞–Ω–∫—ñ–≤
        const chunkManager = new ChunkManager();
        
        // –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –ø–æ—á–∞—Ç–∫–æ–≤–æ–≥–æ —Å–≤—ñ—Ç—É
        function initWorld() {
            chunkManager.clear();
            
            // –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–≥–æ —á–∞–Ω–∫—É
            chunkManager.loadChunk('0,0');
        }
        
        // –û–Ω–æ–≤–ª–µ–Ω–Ω—è HUD
        function updateHUD() {
            document.getElementById('energyBar').textContent = Math.floor(gameState.energy);
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('location').textContent = gameState.location;
        }
        
        // –ú–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ –∑ —Ç–µ—Å—Ç–æ–≤–∏–º –∑–∞–≤–¥–∞–Ω–Ω—è–º
        const modal = document.getElementById('mathModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalQuestion = document.getElementById('modalQuestion');
        const answerInput = document.getElementById('answerInput');
        const submitButton = document.getElementById('submitAnswer');
        const messageEl = document.getElementById('message');
        
        let currentProblem = null;
        
        function showModal(triggerObject) {
            if (gameState.isModalOpen) return;
            
            gameState.isModalOpen = true;
            gameState.isPaused = true;
            
            // –í–∏–±—ñ—Ä –≤–∏–ø–∞–¥–∫–æ–≤–æ–≥–æ –∑–∞–≤–¥–∞–Ω–Ω—è
            currentProblem = mathProblems[Math.floor(Math.random() * mathProblems.length)];
            
            modalTitle.textContent = `–í–∏—è–≤–ª–µ–Ω–æ: ${triggerObject.userData.type}`;
            modalQuestion.textContent = currentProblem.question;
            answerInput.value = '';
            
            modal.classList.add('active');
        }
        
        submitButton.addEventListener('click', () => {
            const answer = parseInt(answerInput.value);
            
            if (answer === currentProblem.answer) {
                showMessage('–ü—Ä–∞–≤–∏–ª—å–Ω–æ! +50 –±–∞–ª—ñ–≤', '#4CAF50');
                gameState.score += 50;
                gameState.energy = Math.min(gameState.energy + 20, gameState.maxEnergy);
                updateHUD();
            } else {
                showMessage('–ü–æ–º–∏–ª–∫–∞! -10 –µ–Ω–µ—Ä–≥—ñ—ó', '#f44336');
                gameState.energy = Math.max(gameState.energy - 10, 0);
                updateHUD();
            }
            
            modal.classList.remove('active');
            gameState.isModalOpen = false;
            gameState.isPaused = false;
        });
        
        function showMessage(text, color) {
            messageEl.textContent = text;
            messageEl.style.display = 'block';
            messageEl.style.borderColor = color;
            
            setTimeout(() => {
                messageEl.style.display = 'none';
            }, 2000);
        }
        
        // –ó–º—ñ–Ω–∞ –ª–æ–∫–∞—Ü—ñ—ó
        function changeLocation(index) {
            currentLocationIndex = index % locations.length;
            gameState.location = locations[currentLocationIndex].name;
            
            // –û—á–∏—â–µ–Ω–Ω—è —Ç–∞ –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü—ñ—è —Å–≤—ñ—Ç—É
            chunkManager.clear();
            initWorld();
            
            updateHUD();
            
            showMessage(`–ü–µ—Ä–µ—Ö—ñ–¥ –¥–æ: ${gameState.location}`, '#2196F3');
        }
        
        // –û–±—Ä–æ–±–∫–∞ –¥–æ—Ç–∏–∫—ñ–≤ –¥–ª—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –≤—ñ–∫–Ω–∞
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            
            if (gameState.isModalOpen || gameState.isPaused) return;
            
            // Raycasting –¥–ª—è –≤–∏—è–≤–ª–µ–Ω–Ω—è –æ–±'—î–∫—Ç—ñ–≤
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            for (const intersect of intersects) {
                if (intersect.object.userData && intersect.object.userData.type === 'trigger') {
                    showModal(intersect.object);
                    break;
                }
                
                if (intersect.object.userData && intersect.object.userData.type === 'enemy') {
                    // –ü–æ—à–∫–æ–¥–∂–µ–Ω–Ω—è –≤–æ—Ä–æ–≥–∞
                    intersect.object.userData.health -= 25;
                    
                    if (intersect.object.userData.health <= 0) {
                        scene.remove(intersect.object);
                        gameState.score += 100;
                        gameState.energy += 10;
                        updateHUD();
                    }
                    
                    break;
                }
            }
        });
        
        // –ê–Ω—ñ–º–∞—Ü—ñ—è
        function animate() {
            requestAnimationFrame(animate);
            
            if (!gameState.isPaused && !gameState.isModalOpen) {
                // –†—É—Ö –≥—Ä–∞–≤—Ü—è
                if (joystickActive) {
                    const moveX = joystickDirection.x * moveSpeed;
                    const moveZ = joystickDirection.y * moveSpeed;
                    
                    camera.position.x += moveX;
                    camera.position.z -= moveZ;
                    
                    // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫–æ–ª—ñ–∑—ñ–π –∑ –ª–∞–Ω–¥—à–∞—Ñ—Ç–æ–º
                    const groundY = simplex.noise2D(camera.position.x * 0.15, camera.position.z * 0.15) * 
                        (locations[currentLocationIndex].name === '–ì–æ—Ä–∏' ? 3 : 
                         locations[currentLocationIndex].name === '–î–∂—É–Ω–≥–ª—ñ' ? 2 : 1.5);
                    
                    camera.position.y = groundY + 2;
                    
                    // –ü–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä–∏ –∑–∞ –Ω–∞–ø—Ä—è–º–∫–æ–º —Ä—É—Ö—É
                    if (Math.abs(moveX) > 0.01 || Math.abs(moveZ) > 0.01) {
                        const targetRotation = Math.atan2(moveX, moveZ);
                        camera.rotation.y = targetRotation;
                    }
                }
                
                // –û–Ω–æ–≤–ª–µ–Ω–Ω—è —á–∞–Ω–∫—ñ–≤
                chunkManager.update(camera.position);
                
                // –û–Ω–æ–≤–ª–µ–Ω–Ω—è –∫—É–ª—å
                gameState.bullets = gameState.bullets.filter(bullet => {
                    bullet.position.add(bullet.userData.velocity);
                    bullet.userData.life--;
                    
                    // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø–æ–ø–∞–¥–∞–Ω—å
                    const enemy = findEnemyAtPosition(bullet.position);
                    if (enemy) {
                        enemy.userData.health -= 50;
                        if (enemy.userData.health <= 0) {
                            scene.remove(enemy);
                            gameState.score += 100;
                        }
                        scene.remove(bullet);
                        return false;
                    }
                    
                    if (bullet.userData.life <= 0) {
                        scene.remove(bullet);
                        return false;
                    }
                    
                    return true;
                });
                
                // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –µ–Ω–µ—Ä–≥—ñ—ó
                if (gameState.energy < gameState.maxEnergy) {
                    gameState.energy += 0.05;
                    updateHUD();
                }
                
                // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø–µ—Ä–µ—Ö–æ–¥—É –Ω–∞ –Ω–æ–≤–∏–π —Ä—ñ–≤–µ–Ω—å
                if (gameState.score >= gameState.level * 500) {
                    gameState.level++;
                    changeLocation(currentLocationIndex + 1);
                }
            }
            
            renderer.render(scene, camera);
        }
        
        function findEnemyAtPosition(position) {
            let result = null;
            scene.children.forEach(child => {
                if (child.userData && child.userData.type === 'enemy') {
                    const distance = child.position.distanceTo(position);
                    if (distance < 1) {
                        result = child;
                    }
                }
            });
            return result;
        }
        
        // –û–±—Ä–æ–±–∫–∞ –∑–º—ñ–Ω–∏ —Ä–æ–∑–º—ñ—Ä—É –≤—ñ–∫–Ω–∞
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // –ü–∞—É–∑–∞
        document.getElementById('pauseButton').addEventListener('touchstart', (e) => {
            e.preventDefault();
            gameState.isPaused = !gameState.isPaused;
            document.getElementById('pauseButton').textContent = gameState.isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
        });
        
        // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è
        initWorld();
        
        // –î–æ–¥–∞–≤–∞–Ω–Ω—è —Ç—Ä–∏–≥–µ—Ä–Ω–∏—Ö –æ–±'—î–∫—Ç—ñ–≤ (–ª–æ–∫–∞—Ü—ñ–π)
        for (let i = 0; i < 3; i++) {
            const triggerGeometry = new THREE.SphereGeometry(1, 8, 8);
            const triggerMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffaa00,
                emissive: 0x442200,
                transparent: true,
                opacity: 0.7
            });
            
            const trigger = new THREE.Mesh(triggerGeometry, triggerMaterial);
            trigger.position.set((i - 1) * 15, 1, -20);
            trigger.userData = {
                type: 'trigger',
                locationIndex: i
            };
            
            scene.add(trigger);
        }
        
        animate();
        
        // –ó–∞–ø–æ–±—ñ–≥–∞–Ω–Ω—è —Å–∫—Ä–æ–ª—É –Ω–∞ –º–æ–±—ñ–ª—å–Ω–∏—Ö
        document.body.addEventListener('touchmove', (e) => {
            if (e.target === canvas || e.target === joystickArea || e.target === shootButton) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>
